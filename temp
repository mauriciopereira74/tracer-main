else if(strcmp(argv[1], "status") == 0){
                /// pegar na informação do servidor

                char fifo[64] = "tmp/fifoS";
                mkfifo(fifo, 0666);

                int status_message = open(fifo, O_RDONLY);

                pid_t pid;

                if(((pid=fork())==0)){

                    struct timeval start;
                    gettimeofday(&start,NULL);

                    Response *response= initStatus(getpid(),argv[1],start,2,fifo);

                    if (write(client_to_server, response, sizeof(struct response)) < 0)
                    {
                        print_error("Failed to write start to client to server fifo.\n");
                        return WRITE_ERROR;
                    }

                    close(client_to_server);
                }

                int status;
                wait(&status);

                char statusM[BUFSIZ];

                if(read(status_message,&statusM,1024)<0){
                    print_error("Failed to read status to server to client fifoS.\n");
                    return READ_ERROR;
                }

                close(status_message);
}

else{ // comando status vem aqui

            printf("HERE!!!!\n");
            int status_message = open(response->fifo, O_WRONLY);
            char statusM[BUFSIZ]; 
            sprintf(statusM, "%s\n", "working");


            if (write(status_message, &statusM, strlen(statusM)) < 0)
            {
                print_error("Failed to write end to client to server fifo.\n");
                return WRITE_ERROR;
            }
}



char *getStatus(Queue *queue)
{
    Response *response = xmalloc(sizeof(Response));
    for(int i=0;i<queue->size;i++){
        response=queue->values[i];
        printf("PID->%d CMD-> %s\n",response->pid,response->cmd);
    }
    free(response);

}


 